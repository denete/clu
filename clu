#!/usr/bin/perl -s

# config.pl should include:
#$config::dataset =
#  (
#   'library_keyword1' => 'data/library_datafile1',
#   'library_keyword2' => 'data/library_datafile2',
#  );
#$config::nick = 'nick_string';
#$config::name = 'name_string';
#$config::server = 'server_address';
#$config::port = 0000;
#$config::pw = 'password_string';
#$config::ssl = 0;
#@config::ch = ('channel_name1', 'channel_name2');
#$config::msg_length = 400;
#1;

# ---

use strict;
use vars qw($channel $mynick $irc $conn %apidata @channels @datakeys %cmds);
use Text::Wrap qw(fill $columns);
use JSON::XS;
use Data::Dumper;
use POE;
use POE::Component::IRC;
use POE::Component::IRC::Plugin::AutoJoin;
use POE::Component::IRC::Plugin::BotAddressed;

require "config.pl";
$columns = $config::msg_length;

@channels = $ARGV[0] ? ("#$ARGV[0]") : @config::ch;
$mynick = $ARGV[1] ? $ARGV[1] : $config::nick;

while ( my ($key, $value) = each(%config::dataset) ) {
    &init_api($key, $value);
}

my $irc = POE::Component::IRC->spawn(
    nick   => $mynick,
    server => $config::server,
    Port => $config::port,
    Ircname => $config::name,
    Username => $mynick,
    Password => $config::pw,
    UseSSL => $config::ssl,
    msg_length => $config::msg_length+50,
);

POE::Session->create(
    package_states => [
        main => [ qw(_default _start irc_001 irc_botcmd_slap irc_public irc_bot_addressed irc_connected irc_disconnect irc_join irc_nick irc_msg) ]
    ],
    heap => { irc => $irc },
);

$poe_kernel->run();

sub _start {
    my $heap = $_[HEAP];
    my $irc = $heap->{irc};
    $irc->plugin_add( 'BotAddressed', POE::Component::IRC::Plugin::BotAddressed->new() );
    $irc->plugin_add( 'AutoJoin', POE::Component::IRC::Plugin::AutoJoin->new(Channels => \@channels) );
    $irc->yield(register => 'all');
    $irc->yield(connect => { });
}

sub irc_001 {
    my $sender = $_[SENDER];

    # Since this is an irc_* event, we can get the component's object by
    # accessing the heap of the sender. Then we register and connect to the
    # specified server.
    my $irc = $sender->get_heap();

    print "Connected to ", $irc->server_name(), "\n";

    # we join our channels
    print "Attempting to join: " . join(' ', @channels, "\n");
    $irc->yield( join => $_ ) for @channels;
    return;
}

# the good old slap
sub irc_botcmd_slap {
    my $nick = (split /!/, $_[ARG0])[0];
    my ($where, $arg) = @_[ARG1, ARG2];
    $irc->yield(ctcp => $where, "ACTION slaps $arg");
    return;
}

sub irc_public {
    return;
}

sub irc_msg {
    my $nick = ( split /!/, $_[ARG0] )[0];
    &get_reference($nick, $nick, $_[ARG2]);
}

sub irc_bot_addressed {
    my $nick = ( split /!/, $_[ARG0] )[0];
    my $channel = $_[ARG1]->[0];
    &get_reference($nick, $channel, $_[ARG2]);
}

sub get_reference {
    my($nick, $route, $what) = @_;
    my $msg = "$nick: ";
    if ($what =~ m/^help/i){
        $msg .= &get_help;
        $irc->yield( privmsg => $route => "$msg" );
    } elsif ($what =~ m/^(\w+)\s?(\w+)?/){
        $msg .= &get_api($1, $2);
        if($msg =~ m/\n/){
            my @msgLines = split('\n', $msg);
            $msg .= @msgLines . " entries returned.";
            $irc->yield( privmsg => $route => "$msg" );
            for my $line (@msgLines){
                $irc->yield( privmsg => $route => "$line" );
            }
        } else {
            # split down any long msg, and send in multiple privmsgs
            my @result = split(/\n/, fill('', '', $msg));
            for my $line (@result) {
                $irc->yield( privmsg => $route => "$line" );
                #sleep 1;
            }
        }
    }
    return;
}

sub get_api {
    my ($lib, $keyword) = @_;
    my ($result);
    my (@name_array);
    if (exists $apidata{ $lib }){
        if ((defined $keyword) && ($keyword ne '') && (defined $lib) && ($lib ne '')){
            if ($keyword eq '_showall'){
                for my $entry (@{$apidata{ $lib }->{apidata}->{api}}){
                    $result .= "$entry->{name}, ";
                }
            } else {
                for my $entry (@{$apidata{ $lib }->{apidata}->{api}}){
                    $result .= "$entry->{name} -- $entry->{def} [$entry->{url}]\n" if $entry->{name} =~ m/$keyword/i;
                }
            }
            $result = "I've got nothing for $lib $keyword." if (!$result);
        } elsif ((defined $lib) && ($lib ne '')) {
                my $randomNode = @{$apidata{ $lib }->{apidata}->{api}}[rand @{$apidata{ $lib }->{apidata}->{api}}];
                $result .= "$randomNode->{name} -- $randomNode->{def}";
                $result .=  "[$randomNode->{url}]" if $randomNode->{url} ne '';
                $result = "I've got nothing for $lib." if (!$result); # we should never see this
        }
    } else {
        $result = "I've got nothing for $lib.";
    }
    return $result;
}

sub init_api {
    my ($myAPIkey, $myAPIvalue) = @_;
    open(FILE,"<$myAPIvalue") || warn "Can't open $myAPIvalue: $!";
    my $jsontext = do { local $/; <FILE>; };
    close(FILE);
    $apidata{ $myAPIkey } = decode_json($jsontext);
}

# We registered for all events, this will produce some debug info.
sub _default {
    my ($event, $args) = @_[ARG0 .. $#_];
    my @output = ("$event: ");

    for my $arg (@$args){
        if(ref $arg eq 'ARRAY'){
            push(@output, '[' . join(', ', @$arg ) . ']');
        } else {
            push(@output, "'$arg'");
        }
    }
    print join(' ', @output, "\n");
    return 0;
}

sub irc_connected {
    #print "Connected to $_[ARG0]\n";
    #print "Attempting to join: " . join(' ', @channels, "\n");
}

sub irc_disconnect {
    print "Disconnected from $_[ARG0]\n";
}

sub irc_join {
    my $nick = ( split /!/, $_[ARG0] )[0];
    printf "*** %s has joined channel %s\n", $nick, $_[ARG1];
}

sub irc_nick {
    my $nick = ( split /!/, $_[ARG0] )[0];
    print "$nick is now $_[ARG1]\n";
}

sub get_help{
    return sprintf("Usage: $mynick <%s> <optional keyword>", join('|', keys(%config::dataset)));
}