#!/usr/bin/perl -s

# config.pl should include:
#$config::dataset =
#  (
#   'library_keyword1' => 'data/library_datafile1',
#   'library_keyword2' => 'data/library_datafile2',
#  );
#$config::nick = 'nick_string';
#$config::name = 'name_string';
#$config::server = 'server_address';
#$config::port = 0000;
#$config::pw = 'password_string';
#$config::ssl = 0;
#@config::ch = ('channel_name1', 'channel_name2');
#$config::msg_length = 450;
#1;

# ---

use strict;
use vars qw($channel $mynick $irc $conn %apidata @channels @datakeys %cmds);
use Text::Wrap qw(fill $columns);
use JSON::XS;
use Data::Dumper;

use POE;
use POE::Component::IRC;
use POE::Component::IRC::Plugin::AutoJoin;
use POE::Component::IRC::Plugin::BotAddressed;
#use POE::Component::IRC::Plugin::BotCommand;

require "config.pl";
$columns = 450;

@channels = $ARGV[0] ? ("#$ARGV[0]") : @config::ch;
$mynick = $ARGV[1] ? $ARGV[1] : $config::nick;
print "Configuration --\nserver: $config::server:$config::port\n";
print "channel(s): " . join(', ', @channels) . "\n";
print "nick: $mynick\n";


while ( my ($key, $value) = each(%config::dataset) ) {
    #$cmds{ $key } = "$mynick $key <optional keyword>";
    &init_api($key, $value);
}

my $irc = POE::Component::IRC->spawn(
    nick   => $mynick,
    server => $config::server,
    Port => $config::port,
    Ircname => $config::name,
    Username => $mynick,
    Password => $config::pw,
    UseSSL => $config::ssl,
    msg_length => $config::msg_length+50,
);

POE::Session->create(
    package_states => [
        main => [ qw(_default _start irc_botcmd_slap irc_public irc_bot_addressed irc_connected irc_disconnect irc_join irc_nick irc_msg) ]
    ],
    heap => { irc => $irc },
);

$poe_kernel->run();

sub _start {
    my $heap = $_[HEAP];
    my $irc = $heap->{irc};

    #$irc->plugin_add('BotCommand', POE::Component::IRC::Plugin::BotCommand->new(
    #    Commands => {
    #        slap   => 'Takes one argument: a nickname to slap.',
    #        %cmds
    #    },
    #    Ignore_unknown => 1,
    #    #Method => 'privmsg',
    #));
    $irc->plugin_add( 'BotAddressed', POE::Component::IRC::Plugin::BotAddressed->new() );
    $irc->plugin_add( 'AutoJoin', POE::Component::IRC::Plugin::AutoJoin->new(Channels => \@channels) );
    $irc->yield(register => 'all');
    $irc->yield(connect => { });
}

# the good old slap
sub irc_botcmd_slap {
    my $nick = (split /!/, $_[ARG0])[0];
    my ($where, $arg) = @_[ARG1, ARG2];
    $irc->yield(ctcp => $where, "ACTION slaps $arg");
    return;
}

sub irc_public {
    return;
}

sub irc_msg {
    my $nick = ( split /!/, $_[ARG0] )[0];
    &get_reference($nick, $nick, $_[ARG2]);
}

sub irc_bot_addressed {
    #my ($kernel, $heap) = @_[KERNEL, HEAP];
    #my $what = $_[ARG2];
    #return if $what =~ m/^help/i;
    #return if $what =~ m/^slap/i;
    my $nick = ( split /!/, $_[ARG0] )[0];
    my $channel = $_[ARG1]->[0];
    &get_reference($nick, $channel, $_[ARG2]);
    
    
    #my $msg = "$nick: ";
    #if ($what =~ m/^(\w+)\s?(\w+)?/){
    #    $msg .= &get_api($1, $2);
    #    if($msg =~ m/\n/){
    #        my @msgLines = split('\n', $msg);
    #        foreach my $line (@msgLines){
    #            $msg .= $line;
    #            $irc->yield( privmsg => $channel => "$msg" );
    #            $msg = '';
    #        }
    #    } else {
    #        $irc->yield( privmsg => $channel => "$msg" );
    #    }
    #}
    #return;
}

sub get_reference {
    my($nick, $route, $what) = @_;
    #my $what = $_[ARG2];
    #return if $what =~ m/^help/i;
    #return if $what =~ m/^slap/i;
    #my $nick = ( split /!/, $nick )[0];
    #my $channel = $route;
    my $msg = "$nick: ";
    if ($what =~ m/^help/i){
        $msg .= &get_help;
        $irc->yield( privmsg => $route => "$msg" );
    } elsif ($what =~ m/^(\w+)\s?(\w+)?/){
        $msg .= &get_api($1, $2);
        if($msg =~ m/\n/){
            my @msgLines = split('\n', $msg);
            foreach my $line (@msgLines){
                $msg .= $line;
                $irc->yield( privmsg => $route => "$msg" );
                $msg = '';
            }
        } else {
            # split down the long msg, and send in multiple privmsgs
            $irc->yield( privmsg => $route => "$msg" );
        }
    }
    return;
}

sub get_api{
    my ($lib, $keyword) = @_;
    my ($result);
    my (@name_array);
    if (exists $apidata{ $lib }){
        if ((defined $keyword) && ($keyword ne '') && (defined $lib) && ($lib ne '')){
            if ($keyword eq '_showall'){
                foreach my $entry (@{$apidata{ $lib }->{apidata}->{api}}){
                    $result .= "$entry->{name}, ";
                }
            } else {
                foreach my $entry (@{$apidata{ $lib }->{apidata}->{api}}){
                    $result .= "$entry->{name} -- $entry->{def} [$entry->{url}]\n" if $entry->{name} =~ m/$keyword/i;
                }
            }
            $result = "I've got nothing for $lib $keyword." if (!$result);
        } elsif ((defined $lib) && ($lib ne '')) {
                my $randomNode = @{$apidata{ $lib }->{apidata}->{api}}[rand @{$apidata{ $lib }->{apidata}->{api}}];
                $result .= "$randomNode->{name} -- $randomNode->{def}";
                $result .=  "[$randomNode->{url}]" if $randomNode->{url} ne '';
                $result = "I've got nothing for $lib." if (!$result); # we should never see this
        }
    } else {
        $result = "I've got nothing for $lib.";
    }
    return $result;
}

sub init_api {
    my ($myAPIkey, $myAPIvalue) = @_;
    open(FILE,"<$myAPIvalue") || warn "Can't open $myAPIvalue: $!";
    my $jsontext = do { local $/; <FILE>; };
    close(FILE);
    $apidata{ $myAPIkey } = decode_json($jsontext);
}

# We registered for all events, this will produce some debug info.
sub _default {
    my ($event, $args) = @_[ARG0 .. $#_];
    my @output = ( "$event: " );

    for my $arg (@$args) {
        if ( ref $arg eq 'ARRAY' ) {
            push( @output, '[' . join(', ', @$arg ) . ']' );
        } else {
            push ( @output, "'$arg'" );
        }
    }
    print join ' ', @output, "\n";
    return 0;
}

sub irc_connected {
    print "Connected to $_[ARG0]\n";
    print "Attempting to join: @channels\n";
}

sub irc_disconnect {
    print "Disconnected from $_[ARG0]\n";
}

sub irc_join {
    my $nick = ( split /!/, $_[ARG0] )[0];
    printf "*** %s has joined channel %s\n", $nick, $_[ARG1];
}

sub irc_nick {
    my $nick = ( split /!/, $_[ARG0] )[0];
    print "$nick is now $_[ARG1]\n";
}

sub get_help{
    return sprintf("Usage: $mynick <%s> <optional keyword>", join('|', keys(%config::dataset)));
}